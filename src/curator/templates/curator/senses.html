<style>

 .node circle {
     fill: #fff;
     stroke: steelblue;
     stroke-width: 3px;
 }

 .node text {
     font: 10px sans-serif;
 }

 .link {
     fill: none;
     stroke: #ccc;
     stroke-width: 2px;
 }

</style>

<svg id="svg{{translation.safe_id}}-{{token}}"></svg>

<div id="test1-{{translation.safe_id}}">
</div>
<div id ="test{{translation.safe_id}}-{{token}}">
    You should not be seeing this.
</div>
<!-- {{translation.hypernyms}} -->
<script type="text/javascript">
 var width = 1100;
 var height = 400;
 var color = d3.scaleOrdinal(d3.schemeCategory10);
 $('a[href="#menu2-{{translation.safe_id}}"]').on('hidden.bs.tab',function(e){
     console.log("hide");
     var svg = d3.select("#svg{{translation.safe_id}}");
     svg.selectAll("*").remove();
 });

 $('a[href="#menu2-{{translation.safe_id}}-{{token}}"]').on('shown.bs.tab',function(e){
     console.log("show");
     var word = d3.select('a[href="#menu2-{{translation.safe_id}}"]')
     console.log("Graph....");
     d3.json("/curator/segments/{{page_obj.number}}/wordsense/{{token}}").then(treeData =>{
         console.log(treeData);

         // Assigns parent, children, height, depth
         const root = d3.hierarchy(treeData, function(d) { return d.children; });
         root.x0 = height / 2;
         root.y0 = 0;

         var margin = {top: 10, right: 10, bottom: 10, left: 40};
         var svg = d3.select("#svg{{translation.safe_id}}-{{token}}")
                     .attr("viewBox", [-margin.left, -margin.top, width, 400]);
         //To prevent adding multiple graphs whenever ths sense is clicked
         svg.selectAll("*").remove();


         const gLink = svg.append("g")
                          .attr("fill", "none")
                          .attr("stroke", "#555")
                          .attr("stroke-opacity", 0.4)
                          .attr("stroke-width", 1.5);

         const gNode = svg.append("g")
                          .attr("cursor", "pointer")
                          .attr("pointer-events", "all");


         var i = 0;


         // declares a tree layout and assigns the size
         var treemap = d3.tree().size([height, width]);



         // Collapse after the second level
         //root.children.forEach(collapse);
         update(root);

         // Collapse the node and all it's children
         function collapse(d) {
             if(d.children) {
                 d._children = d.children
                 d._children.forEach(collapse)
                 d.children = null
             }
         }

         function update(source) {

             // Assigns the x and y position for the nodes
             var treeData = treemap(root);
             const duration = d3.event && d3.event.altKey ? 2500 : 250;

             // Compute the new tree layout.
             var nodes = treeData.descendants(),
                 links = treeData.descendants().slice(1);

             // Normalize for fixed-depth.
             nodes.forEach(function(d){
                 d.y = d.depth *90});

             // ****************** Nodes section ***************************

             // Update the nodes...
             var node = svg.selectAll('g.node')
                           .data(nodes, function(d) {return d.id || (d.id = ++i); });

             // Enter any new modes at the parent's previous position.
             var nodeEnter = node.enter().append('g')
                                 .attr('class', 'node')
                                 .attr("transform", function(d) {
                                     return "translate(" + source.y0 + "," + source.x0 + ")";
                                 })
                                 .on('click', click)
                                 .on("contextmenu", rtclick)
                                 .on("mouseover", mouseover)
                                 .on("mouseout", mouseout);

             // Add Circle for the nodes
             nodeEnter.append('circle')
                      .attr('class', 'node')
                      .attr('r', 1e-6)
                      .style("fill", function(d) {
                          return d._children ? "lightsteelblue" : "#fff";
                      });


             // Add labels for the nodes
             nodeEnter.append('text')
                      .attr("dy", "-10")
                      .attr("x", 0)
                      .attr("text-anchor", "middle")
                      .text(function(d) { return d.data.value; });

             // UPDATE
             var nodeUpdate = nodeEnter.merge(node);

             // Transition to the proper position for the node
             nodeUpdate.transition()
                       .duration(duration)
                       .attr("transform", function(d) {
                           return "translate(" + d.y + "," + d.x + ")";
                       });

             // Update the node attributes and style
             nodeUpdate.select('circle.node')
                       .attr('r', 4)
                       .style("fill", function(d) {
                           return d._children ? "lightsteelblue" : "#fff";
                       })
                       .attr('cursor', 'pointer');


             // Remove any exiting nodes
             var nodeExit = node.exit().transition()
                                .duration(duration)
                                .attr("transform", function(d) {
                                    return "translate(" + source.y + "," + source.x + ")";
                                })
                                .remove();

             // On exit reduce the node circles size to 0
             nodeExit.select('circle')
                     .attr('r', 1e-6);

             // On exit reduce the opacity of text labels
             nodeExit.select('text')
                     .style('fill-opacity', 1e-6);

             // ****************** links section ***************************

             // Update the links...
             var link = svg.selectAll('path.link')
                           .data(links, function(d) { return d.id; });

             // Enter any new links at the parent's previous position.
             var linkEnter = link.enter().insert('path', "g")
                                 .attr("class", "link")
                                 .attr('d', function(d){
                                     var o = {x: source.x0, y: source.y0}
                                     return diagonal(o, o)
                                 });

             // UPDATE
             var linkUpdate = linkEnter.merge(link);

             // Transition back to the parent element position
             linkUpdate.transition()
                       .duration(duration)
                       .attr('d', function(d){ return diagonal(d, d.parent) });

             // Remove any exiting links
             var linkExit = link.exit().transition()
                                .duration(duration)
                                .attr('d', function(d) {
                                    var o = {x: source.x, y: source.y}
                                    return diagonal(o, o)
                                })
                                .remove();

             // Store the old positions for transition.
             nodes.forEach(function(d){
                 d.x0 = d.x;
                 d.y0 = d.y;
             });

             // Creates a curved (diagonal) path from parent to the child nodes
             function diagonal(s, d) {

                 path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`

                 return path
             }

             // Toggle children on click.
             function click(d) {
                 if (d.children) {
                     d._children = d.children;
                     d.children = null;
                 } else {
                     d.children = d._children;
                     d._children = null;
                 }
                 update(d);
             }
             function rtclick(d, i) {
                 nodes.splice(i, 1);
                 d3.event.preventDefault();
                 console.log(d);
                 console.log(i);
                 if (d.children) {
                     //d._children = d.children;
                     d.children = null;
                 }
                 update(d);
             }

             function mouseover(d) {
                 var g = d3.select(this); // The node
                 // The class is used to remove the additional text later
                 var info = g.append('text')
                             .classed('info alert alert-primary', true)
                             .attr('x', -20)
                             .attr('y', 15)
                             .text(d.data.defn);
             }


             function mouseout(d) {
                 d3.select(this).select('.info').remove()

             }

         }

         d3.select("#test{{translation.safe_id}}-{{token}}").text("");
     }).catch(function(error) {
         // Do some error handling.
     });

     console.log("Done.");
 });


</script>
